# idea:

设计一种算法, 可以快速从一个长句子中挑出重要的信息:

比如一句话: $[x_1, x_2,\cdots ,x_n]$, 

**有一个算法A:** 可以将KV-cache分块, 分为$[x_1^{(1)}, x_2^{(1)},\cdots, x_i^{(1)}, x_{i+1}^{(2)}, x_{i+2}^{(2)}, \cdots, x_{(n-1)i+1}^{(n)},x_{(n-1)i+2}^{(n)},\cdots]$ 分成了n个区块. 

**同时我还有一个算法B**: 可以生成一个链表, 链表为: $\{1:None, 2:1, \cdots,n:k(k<n)\}$, 这个链表表明: 某个区块$k$和$n$最为相近. 

**最后我有一个算法C**, 使得对一个query, 我可以找到和该query最相近的区块$K$.

**算法D**: 对一个句子 $[K_i, K_{i+1},\cdots,K_s, query]$, 假设句子长度不超过training length, 那么通过查询**算法B**得到的链表, 我可以把一个新的区块$K_{i-1}$添加到我们的句子中来.



**算法A**: 使用自适应context window来对kv-cache进行切割

**算法C:** 考虑query前M个分块, 对每个分块中的keys, 计算$q^Tk$的大小, 然后取平均值, 最后找到均值最大的那个区块.

**算法B:** 对于一个区块的每个query, 都会对应一个最相似的区块, 然后根据多数投票法则, 选择得票最高的区块.

commemt: 
1. 一般的做法: 对于query, 我们会从KV-cache中找到最合适的blocks, 一般是衡量这个block是否和query相似. 我的想法是, 找到一个和query相似的block, 然后根据已有的链表选择重要的keys(算法D)

2. 算法B的合理性在于: 我在算法A中使用了自适应地context-window,  这样会把句子中相似的tokens放在一个block中, 这样在进行query间的multi-vote的时候, 投票的结果会表现出一致性(待验证！！！).
3. 算法D的合理性可以通过以下实验说明(朋友的朋友还是我的朋友)



实验目的: 

假设我们存在三个token: [token1, token2, token3], 若$q_3^T\cdot k_1>q_3^T\cdot k_2$, 那么我希望: 寻找所有和$token_3$关系近的tokens, 假设为token4, 那么有: 

$q_4^T\cdot k_1>q_4\cdot k_2$.

进一步, 我希望这个性质可以推广到block上. 目前对于token的验证已经做完, 基本符合. 因此需要好好设计block的大小和划分方式.